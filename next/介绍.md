# 介绍

Next.js 是一个基于 React 全栈框架，由 Vercel 开发和维护，那么它有什么优势呢？

- **SSR**: 服务端渲染，可以提高页面加载速度(现在会 SSR 的人才并不多，可以提升你的竞争力)
- **SSG**: 静态站点生成，可以生成静态页面，类似于 Vitepress / Astro 等静态站点生成工具
- **SEO**: Next.js 提供了 SEO 优化，让你的网站更容易被搜索引擎收录
- **AI:** Vercel 提供了 AI SDK 可以跟 Next.js 轻松结合，让你可以轻松实现 AI 应用
- **服务端操作**: Next.js 提供了服务端操作，顺便学习服务端知识，为以后做全栈开发打下基础
- **社区丰富**: Next.js 拥有庞大的社区，可以让你轻松找到解决方案
- **部署:** 支持多种部署选项，与 Vercel 等平台集成良好，可以快速部署

## 什么是 React Compiler?

React Compiler 是 Next.js 用于自动优化组件渲染来提高性能的工具，在之前的话，我们需要手动优化 `useMemo` / `useCallback` / `memo` 等，现在 Next.js 会自动优化，你只需要写代码即可,减少心智负担。

如何开启 React Compiler? `如果你在选项中选择 yes 则无需安装（通过脚手架初始化项目时选择 yes）`

```bash
npm install -D babel-plugin-react-compiler

```

next.config.ts

```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactCompiler: true, //开启即可
};

export default nextConfig;
```

## 什么是 App Router?

Next.js 有两套路由系统，一个是旧的 `Pages Router` 路由系统，一个是新的 `App Router` 路由系统。

首先 Next.js 首推的是 `App Router` 路由系统

- `Pages Router` 的路由系统是会把 `pages` 目录下的所有 jsx/tsx 文件，都转换成路由，例如 `pages/index.tsx` 会转换成 `/` 路由，`pages/about.tsx` 会转换成 `/about` 路由，这样导致我们不能把组件写到 `pages` 目录下

目录结构如下

```txt
 └── pages
    ├── index.tsx -> /
    ├── login.tsx -> /login
    ├── api
    │   └── user.tsx -> /api/user
    ├── posts
    │   └── [id].tsx -> /posts/[id]
    └── blog
        ├── index.tsx -> /blog
        └── setting.tsx -> /blog/setting

```

- `App Router` 的路由系统是根据约定定义的，app 目录下的每个文件夹都代表一个路由段（route segment），并直接映射到 URL 路径。无需配置路由表，框架会根据您的文件结构自动处理，目录结构如下

```txt
src/
└── app
    ├── page.tsx -> / 首页
    ├── layout.tsx -> 布局组件
    ├── template.tsx -> 模板组件
    ├── loading.tsx -> 加载组件
    ├── error.tsx -> 错误组件
    └── not-found.tsx -> 404组件
    ├── xiaoman
    │   └── page.tsx -> /xiaoman 小满页面
    └── daman
        └── page.tsx -> /daman 大满页面

```

- `Pages Router` 读取数据需要使用 `getServerSideProps` / `getStaticProps` / `getStaticPaths` 等函数，而 `App Router` 则不需要，直接在组件中使用 `fetch` 调用即可。

Pages Router:

```tsx
export async function getServerSideProps() {
  const res = await fetch("xxx");
  const data = await res.json();
  return { props: { data } };
}
export default function Home({ data }) {
  return <div>{data.name}</div>;
}
```

App Router:

```tsx
export default async function Home() {
  const res = await fetch("xxx");
  const data = await res.json();
  return <div>{data.name}</div>;
}
```

### layout && template

`layout(布局)` 布局是多个页面共享 UI，例如导航栏、侧边栏、底部等。
`template(模板)` 基本功能跟布局一样，只是不会保存状态

布局和模板的特点就是：

- **布局嵌套**: 支持多层布局嵌套，构建复杂的页面结构
- **状态管理**: 布局会在页面切换时保持状态，而模板会重新渲染
- **根布局**: app/layout.tsx 是必须存在的根布局文件
- **渲染顺序**: 当布局和模板同时存在时，渲染顺序为 layout → template → page

### loading(加载)

Next.js 的 loading 是借助了 `Suspense` 实现的，Suspense 的具体用法请参考 [Suspense 组件](https://message163.github.io/react-docs/react/components/suspense.html)

### error(错误)

Next.js 的 error 是借助了 `Error Boundary` 实现的。

### not-found(404)

其实 Next.js 默认会生成一个 404 页面，但我们可能自定义 404 页面，只需要在 app 目录下创建一个 not-found.tsx 文件即可

### 路由导航

路由导航是指我们在 Next.js 中跳转页面的方式，例如原始的 `<a>` 标签，等。

在 Next.js 中，共有四种方式提供跳转:

- `Link` 组件
- `useRouter` Hook (客户端组件)
- `redirect` 函数 (服务端组件)
- `History` API (浏览器 API 本文略过用的不多 了解即可)

#### Link 组件

`<Link>` 是一个内置组件，在 a 标签的基础上扩展了功能，并且还能用来实现`预获取`(prefetch)，以及保持`滚动`位置(scroll)等。

##### 基本用法

```tsx
import Link from "next/link";
export default function Home() {
  return (
    <div>
      <Link href="/about">跳转About页面</Link>
      <Link href={{ pathname: "/about", query: { name: "张三" } }}>
        跳转About并且传入参数
      </Link>
      <Link href="/page" prefetch={true}>
        预获取page页面
      </Link>
      <Link href="/xm" scroll={true}>
        保持滚动位置
      </Link>
      <Link href="/daman" replace={true}>
        替换当前页面
      </Link>
    </div>
  );
}
```

#### useRouter Hook

useRouter 可以在代码中根据逻辑跳转页面，例如根据用户权限跳转不同的页面。

使用该 hook **需要在客户端组件中**。需要在顶层编写 `'use client'` 声明这是客户端组件。

```tsx
"use client";
import { useRouter } from "next/navigation";
export default function Page() {
  const router = useRouter();
  return (
    <>
      <button onClick={() => router.push("/page")}>跳转page页面</button>
      <button onClick={() => router.replace("/page")}>替换当前页面</button>
      <button onClick={() => router.back()}>返回上一页</button>
      <button onClick={() => router.forward()}>跳转下一页</button>
      <button onClick={() => router.refresh()}>刷新当前页面</button>
      <button onClick={() => router.prefetch("/about")}>预获取about页面</button>
    </>
  );
}
```

#### redirect 函数

redirect 函数可以用于服务端组件/客户端组件中跳转页面，例如根据用户权限跳转不同的页面。

> 在 Next.js 中 redirect 的状态是：307 临时重定向

```tsx
import { redirect } from "next/navigation";
export default async function Page() {
  const checkLogin = await checkLogin();
  //如果用户未登录，则跳转到登录页面
  if (!checkLogin) {
    redirect("/login");
  }
  return (
    <div>
      <h1>Page</h1>
    </div>
  );
}
```

#### permanentRedirect 函数

permanentRedirect 跟上面的 redirect 的区别是：permanentRedirect 是`永久重定向`，而 redirect 是`临时重定向`。

> 在 Next.js 中 permanentRedirect 的状态是：308 永久重定向

```tsx
//用法跟redirect一样，只是状态码不同
import { permanentRedirect } from "next/navigation";
export default async function Page() {
  const checkLogin = await checkLogin();
  if (!checkLogin) {
    permanentRedirect("/login");
  }
}
```

##### permanentRedirect / redirect 参数说明

这两个函数都接受以下参数：

- `path`：字符串类型，表示重定向的目标 URL（支持相对路径和绝对路径）
- `type`：可选参数，值为 `replace` 或 `push`，用于控制重定向的行为

**关于 `type` 参数的默认行为：**

- 在 **Server Actions** 中：默认使用 `push`，会将新页面添加到浏览器历史记录
- 在 **其他场景** 中：默认使用 `replace`，会替换当前的浏览器历史记录

你可以通过显式指定 type 参数来覆盖默认行为。

> ⚠️ 注意：type 参数在服务端组件中无效，仅在客户端组件和 Server Actions 中生效。
