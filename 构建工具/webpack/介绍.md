# Webpack 基础

### webpack 是什么

webpack 是一个现代 JavaScript 应用程序的静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。

作用：

- 打包：可以把多个 Javascript 文件打包成一个文件，减少服务器压力和下载带宽
- 转换：把拓展语言转换成为普通的 JavaScript，让浏览器顺利运行
- 优化：前端变的越来越复杂后，性能也会遇到问题，而 WebPack 也开始肩负起了优化和提升性能的责任

### webpack 的核心概念

- entry: 入口
- output: 输出
- loader: 模块转换器，用于把模块原内容按照需求转换成新内容

  - 简述
    - 通常 loader 是按 从右往左，从下往上 的顺序执行的，将上一个 loader 的执行结果传递给下一个 loader
  - 编写要点

    1. loader 本质上是一个**函数**，函数中的 `this` 作为上下文会被 `webpack` 填充，因此我们不能将 `loader` 设为一个**箭头函数**
    2. 函数接受一个参数，为 `webpack` 传递给 `loader` 的文件源内容
    3. 函数中 `this` 是由 `webpack` 提供的对象，能够获取当前 `loader` 所需要的各种信息
    4. 函数中有异步操作或同步操作，异步操作通过 `this.callback` 返回，返回值要求为 `string` 或者 `Buffer`
    5. 一般在编写`loader`的过程中，保持功能单一，避免做多种功能
       如`less`文件转换成 `css `文件也不是一步到位，而是 `less-loader`、`css-loader`、`style-loader`几个 `loader `的链式调用才能完成转换

    代码如下所示：

    ```js
    // 导出一个函数，source 为 webpack 传递给 loader 的文件源内容
    module.exports = function (source) {
      const content = doSomeThing2JsString(source);

      // 如果 loader 配置了 options 对象，那么this.query将指向 options
      const options = this.query;

      // 可以用作解析其他模块路径的上下文
      console.log("this.context");

      /*
       * this.callback 参数：
       * error：Error | null，当 loader 出错时向外抛出一个 error
       * content：String | Buffer，经过 loader 编译后需要导出的内容
       * sourceMap：为方便调试生成的编译后内容的 source map
       * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
       */
      this.callback(null, content); // 异步
      return content; // 同步
    };
    ```

- 插件(plugins): 扩展插件，可以用来做一些 loader 无法做到的事情

  - `webpack` 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务
  - `webpack` 编译会创建两个核心对象：

    - compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子
    - compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建

  - 编写要点
    - 插件必须是一个函数或者是一个包含 `apply` 方法的对象，这样才能访问 `compiler` 实例
    - 传给每个插件的 `compiler` 和 `compilation` 对象都是同一个引用，因此不建议修改
    - 异步的事件需要在插件处理完任务时调用回调函数通知 `webpack` 进入下一个流程，不然会卡住

  实现`plugin`的模板如下：

  ```js
  class MyPlugin {
    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象
    apply(compiler) {
      // 找到合适的事件钩子，实现自己的插件功能
      compiler.hooks.emit.tap("MyPlugin", (compilation) => {
        // compilation: 当前打包构建流程的上下文
        console.log(compilation);

        // do something...
      });
    }
  }
  ```

  在 `emit` 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容

- 模块: 项目中使用的每个文件都是一个 模块
- chunk:
  - 在打包过程中，模块会被合并成 chunk。 chunk 合并成 chunk 组，并形成一个通过模块互相连接的图(ModuleGraph)
  - 一个 chunk 组中可能有多个 chunk。例如，`SplitChunksPlugin` 会将一个 chunk 组拆分为一个或多个 chunk。

```js
// ./webpack.config.js

module.exports = {
  entry: "./index.js",
};
```

这会创建出一个名为 main 的 chunk 组（main 是入口起点的默认名称）。 此 chunk 组包含 ./index.js 模块。随着 parser 处理 ./index.js 内部的 import 时， 新模块就会被添加到此 chunk 中。

### webpack 编译流程

1. 初始化流程：

   - 从配置文件 与 `Shell` 读取与合并参数（也会合并默认参数），并初始化需要使用的`插件`和配置插件的`执行环境`所需要的参数

     - 将各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins`
     - 完成上述步骤之后，则开始初始化 `Compiler` 编译对象，该对象掌控者 `webpack` 生命周期，不执行具体的任务，只是进行一些调度工作
     - `Compiler` 对象继承自 `Tapable`，初始化时定义了很多钩子函数

2. 编译构建流程：

   - 根据配置中的 `entry` 找出所有的入口文件
   - 初始化完成后会调用 `Compiler` 的 `run` 来真正启动 `webpack` 编译构建流程，主要流程如下（4、5 属于输出流程）：

     1. `compile` 开始编译
     2. `make` 从入口点分析模块及其依赖的模块，创建这些模块对象
     3. `build-module` 构建模块
     4. `seal` 封装构建结果
     5. `emit` 把各个 chunk 输出到结果文件

   #### compile 编译

   执行了 `run` 方法后，首先会触发 `compile`，主要是构建一个 `Compilation` 对象

   该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象

   #### make 编译模块

   当完成了上述的 `compilation` 对象后

   - 解析入口 js 文件，通过对对应的工厂方法创建模块，保存 `compilation` 对象上
   - 主要执行 `_addModuleChain()` 函数，如下：

   ```js
    _addModuleChain(context, dependency, onModule, callback) {
        ...
        // 根据依赖查找对应的工厂函数
        const Dep = /** @type {DepConstructor} */ (dependency.constructor);
        const moduleFactory = this.dependencyFactories.get(Dep);

        // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象
        moduleFactory.create({
            dependencies: [dependency]
            ...
        }, (err, module) => {
            ...
            const afterBuild = () => {
                this.processModuleDependencies(module, err => {
                if (err) return callback(err);
                callback(null, module);
                });
            };

            this.buildModule(module, false, null, null, err => {
                ...
                afterBuild();
            })
        })
    }
   ```

   过程如下：

   `_addModuleChain` 中接收参数 `dependency`(传入的入口依赖)，使用对应的工厂函数 `NormalModuleFactory.create` 方法生成一个空的 `module` 对象
   回调中会把此 `module` 存入 `compilation.modules` 对象和 `dependencies.module` 对象中，由于是入口文件，也会存入 `compilation.entries` 中
   随后执行 `buildModule` 进入真正的构建模块 `module` 内容的过程

   #### build module 完成模块编译

   这里主要调用配置的 `loaders` ，将我们的模块转成标准的 `JS` 模块

   在用 `Loader` 对一个模块转换完后，使用 `acorn` 解析转换后的内容，输出对应的抽象语法树（`AST`），以方便 `Webpack` 后面对代码的分析

   从配置的入口模块开始，分析其 `AST` ，当遇到 `require` 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系

3. 输出流程

   #### seal 输出资源

   `seal` 方法主要是要生成 `chunks` ，对 `chunks` 进行一系列的优化操作，并生成要输出的代码

   `webpack` 中的 `chunk` ，可以理解为配置在 `entry` 中的模块，或者是动态引入的模块

   根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `Chunk`，再把每个 `Chunk` 转换成一个单独的文件加入到输出列表

   #### emit 输出完成

   在确定好输出内容后，根据配置确定输出的路径和文件名

   ```js
   output: {
       path: path.resolve(__dirname, 'build'),
           filename: '[name].js'
   }
   ```

   在 `Compiler` 开始生成文件前，钩子 `emit` 会被执行，这是我们修改最终文件的最后一个机会

   从而`webpack`整个打包过程则结束了

### webpack 优化

**Treeshaking**

前提：使用 ES2015 模块语法（即 import 和 export）

Webpack Treeshaking 是 n 种优化的一起工作的效果，其实主要是 三种优化的综合即：

- usedExports 优化：即删除模块中未使用的导出变量，从而进一步删除相关的无副作用语句。

  - 使用：通过 `optimization.usedExports` 配置启用 usedExports 优化
  - 具体说明：通过 dependency 的 active 状态来判断模块内的变量是否被使用，然后在代码生成阶段如果导出变量未被使用，则代码生成不生成相应变量的导出属性，这样就会进一步使得导出变量依赖的代码片段成为死代码，再借助后续的 minify 的 DCE 功能进行删除。

- sideEffects 优化：删除模块图中未被使用导出变量的模块

  - 使用：通过 `optimization.sideEffects` 配置启用 sideEffects 优化，生产环境模式下默认开启
  - 删除模块要满足的 2 个条件：
  - 该模块的任何导出变量都没有被使用
  - 该模块是 side-effect-free（无副作用）

- DCE（dead code elimination） 优化：即一般的 minify 工具实现的死代码删除，其他工具也可以实现类似功能如 webpack 的 ConstPlugin

以下面的 demo 为例：

- 这里的 lib.js 的 b 未被使用，最终 lib.js 的产物里不包含 b 的相关代码，即为 usedExports 优化（删除导出变量 b）
- 这里的 util.js 的任何导出变量都未被使用，最终产物里没有 util 模块，则为 sideEffects 优化 （删除未使用模块 util）
- 里的 bootstrap.js 里的 console.log 是不会被执行的代码，最终产物里会被删除，则为 DCE（删除不会被执行的语句）

```js
// index.js
import { a } from "./lib";
import { c } from "./util";
import "./bootstrap";

console.log(a);

// lib.js
export const a = 1;
export const b = 2;

// util.js
export const c = 3;
export const d = 4;

// bootstrap.js
console.log("bootstrap");
if (false) {
  console.log("bad");
} else {
  console.log("good");
}
```

- package.json 文件里设置 sideEffects：
  - false 告诉 webpack，此模块没有副作用，可以进行 tree shaking

### webpack HMR 热更新

[文件监听和热更新原理分析](https://juejin.cn/post/6844904134697549832)

### 参考资料

- [跟着"呆妹"来学 webpack(基础篇)](https://juejin.im/post/5e9ada576fb9a03c391300a1#heading-26)
- [简单实现 babel-plugin-import 插件](https://www.cnblogs.com/axuebin/p/babel-plugin-import.html)
- [彻底掌握 Webpack 中 Loader 和 Plugin 的机制](https://juejin.cn/post/7068216285724672008?searchId=20230918135500CCFB068457C39ADCC563#heading-10)
- [详见 Webpack Treeshaking](https://juejin.cn/post/7358450927109963810?searchId=20240514143040B86CD5B5C9D826009D54)
