# Webpack 基础

### webpack 是什么

webpack 是一个现代 JavaScript 应用程序的静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。

作用：

- 打包：可以把多个 Javascript 文件打包成一个文件，减少服务器压力和下载带宽
- 转换：把拓展语言转换成为普通的 JavaScript，让浏览器顺利运行
- 优化：前端变的越来越复杂后，性能也会遇到问题，而 WebPack 也开始肩负起了优化和提升性能的责任

### webpack 的核心概念

- entry: 入口
- output: 输出
- loader: 模块转换器，用于把模块原内容按照需求转换成新内容
  通常 loader 是按 从右往左，从下往上 的顺序执行的，将上一个 loader 的执行结果传递给下一个 loader
- 插件(plugins): 扩展插件，在 webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情
  - 简述工作逻辑
    在启动 webvpack 后会创建一个 compiler 实例，贯穿启动-关闭全过程
    每次热更新/重新启动 会生成一个 compilation 实例，其包含这次编译的相关信息，例如 修改的文件等
    而 plugin 就是利用 compiler 和 compilation 暴露出来的 钩子，来实现对各个时期代码的处理
- 模块: 项目中使用的每个文件都是一个 模块
- chunk:
  - 在打包过程中，模块会被合并成 chunk。 chunk 合并成 chunk 组，并形成一个通过模块互相连接的图(ModuleGraph)
  - 一个 chunk 组中可能有多个 chunk。例如，`SplitChunksPlugin` 会将一个 chunk 组拆分为一个或多个 chunk。

```js
// ./webpack.config.js

module.exports = {
  entry: "./index.js",
};
```

这会创建出一个名为 main 的 chunk 组（main 是入口起点的默认名称）。 此 chunk 组包含 ./index.js 模块。随着 parser 处理 ./index.js 内部的 import 时， 新模块就会被添加到此 chunk 中。

### webpack 编译流程

1. 初始化流程：

   - 从配置文件 与 `Shell` 读取与合并参数（也会合并默认参数），并初始化需要使用的`插件`和配置插件的`执行环境`所需要的参数

     - 将各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins`
     - 完成上述步骤之后，则开始初始化 `Compiler` 编译对象，该对象掌控者 `webpack` 生命周期，不执行具体的任务，只是进行一些调度工作
     - `Compiler` 对象继承自 `Tapable`，初始化时定义了很多钩子函数

2. 编译构建流程：

   - 根据配置中的 `entry` 找出所有的入口文件
   - 初始化完成后会调用 `Compiler` 的 `run` 来真正启动 `webpack` 编译构建流程，主要流程如下（4、5 属于输出流程）：

     1. `compile` 开始编译
     2. `make` 从入口点分析模块及其依赖的模块，创建这些模块对象
     3. `build-module` 构建模块
     4. `seal` 封装构建结果
     5. `emit` 把各个 chunk 输出到结果文件

   #### compile 编译

   执行了 `run` 方法后，首先会触发 `compile`，主要是构建一个 `Compilation` 对象

   该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象

   #### make 编译模块

   当完成了上述的 `compilation` 对象后

   - 解析入口 js 文件，通过对对应的工厂方法创建模块，保存 `compilation` 对象上
   - 主要执行 `_addModuleChain()` 函数，如下：

   ```js
    _addModuleChain(context, dependency, onModule, callback) {
        ...
        // 根据依赖查找对应的工厂函数
        const Dep = /** @type {DepConstructor} */ (dependency.constructor);
        const moduleFactory = this.dependencyFactories.get(Dep);

        // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象
        moduleFactory.create({
            dependencies: [dependency]
            ...
        }, (err, module) => {
            ...
            const afterBuild = () => {
                this.processModuleDependencies(module, err => {
                if (err) return callback(err);
                callback(null, module);
                });
            };

            this.buildModule(module, false, null, null, err => {
                ...
                afterBuild();
            })
        })
    }
   ```

   过程如下：

   `_addModuleChain` 中接收参数 `dependency`(传入的入口依赖)，使用对应的工厂函数 `NormalModuleFactory.create` 方法生成一个空的 `module` 对象
   回调中会把此 `module` 存入 `compilation.modules` 对象和 `dependencies.module` 对象中，由于是入口文件，也会存入 `compilation.entries` 中
   随后执行 `buildModule` 进入真正的构建模块 `module` 内容的过程

   #### build module 完成模块编译

   这里主要调用配置的 `loaders` ，将我们的模块转成标准的 `JS` 模块

   在用 `Loader` 对一个模块转换完后，使用 `acorn` 解析转换后的内容，输出对应的抽象语法树（`AST`），以方便 `Webpack` 后面对代码的分析

   从配置的入口模块开始，分析其 `AST` ，当遇到 `require` 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系

3. 输出流程

   #### seal 输出资源

   `seal` 方法主要是要生成 `chunks` ，对 `chunks` 进行一系列的优化操作，并生成要输出的代码

   `webpack` 中的 `chunk` ，可以理解为配置在 `entry` 中的模块，或者是动态引入的模块

   根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `Chunk`，再把每个 `Chunk` 转换成一个单独的文件加入到输出列表

   #### emit 输出完成

   在确定好输出内容后，根据配置确定输出的路径和文件名

   ```js
   output: {
       path: path.resolve(__dirname, 'build'),
           filename: '[name].js'
   }
   ```

   在 `Compiler` 开始生成文件前，钩子 `emit` 会被执行，这是我们修改最终文件的最后一个机会

   从而`webpack`整个打包过程则结束了

### webpack 优化

**Treeshaking**

前提：使用 ES2015 模块语法（即 import 和 export）

Webpack Treeshaking 是 n 种优化的一起工作的效果，其实主要是 三种优化的综合即：

- usedExports 优化：即删除模块中未使用的导出变量，从而进一步删除相关的无副作用语句。

  - 使用：通过 `optimization.usedExports` 配置启用 usedExports 优化
  - 具体说明：通过 dependency 的 active 状态来判断模块内的变量是否被使用，然后在代码生成阶段如果导出变量未被使用，则代码生成不生成相应变量的导出属性，这样就会进一步使得导出变量依赖的代码片段成为死代码，再借助后续的 minify 的 DCE 功能进行删除。

- sideEffects 优化：删除模块图中未被使用导出变量的模块

  - 使用：通过 `optimization.sideEffects` 配置启用 sideEffects 优化，生产环境模式下默认开启
  - 删除模块要满足的 2 个条件：
  - 该模块的任何导出变量都没有被使用
  - 该模块是 side-effect-free（无副作用）

- DCE（dead code elimination） 优化：即一般的 minify 工具实现的死代码删除，其他工具也可以实现类似功能如 webpack 的 ConstPlugin

以下面的 demo 为例：

- 这里的 lib.js 的 b 未被使用，最终 lib.js 的产物里不包含 b 的相关代码，即为 usedExports 优化（删除导出变量 b）
- 这里的 util.js 的任何导出变量都未被使用，最终产物里没有 util 模块，则为 sideEffects 优化 （删除未使用模块 util）
- 里的 bootstrap.js 里的 console.log 是不会被执行的代码，最终产物里会被删除，则为 DCE（删除不会被执行的语句）

```js
// index.js
import { a } from "./lib";
import { c } from "./util";
import "./bootstrap";

console.log(a);

// lib.js
export const a = 1;
export const b = 2;

// util.js
export const c = 3;
export const d = 4;

// bootstrap.js
console.log("bootstrap");
if (false) {
  console.log("bad");
} else {
  console.log("good");
}
```

- package.json 文件里设置 sideEffects：
  - false 告诉 webpack，此模块没有副作用，可以进行 tree shaking

### 参考资料

- [跟着"呆妹"来学 webpack(基础篇)](https://juejin.im/post/5e9ada576fb9a03c391300a1#heading-26)
- [简单实现 babel-plugin-import 插件](https://www.cnblogs.com/axuebin/p/babel-plugin-import.html)
- [彻底掌握 Webpack 中 Loader 和 Plugin 的机制](https://juejin.cn/post/7068216285724672008?searchId=20230918135500CCFB068457C39ADCC563#heading-10)
- [详见 Webpack Treeshaking](https://juejin.cn/post/7358450927109963810?searchId=20240514143040B86CD5B5C9D826009D54)
