# 基础

### 变量

- Rust 是强类型语言，但具有自动判断变量类型的能力
- 默认情况下，Rust 中的变量是不可变的
- 使用 mut 关键字声明为可变变量

```rust

let a = 123
a  = 234 // error
let mut b = 123
b = 345 // success
b = 2.33 // error Rust 语言不允许精度有损失的自动数据类型转换

// ====================

// 以下程序是合法的：
let a = 123;   // 可以编译，但可能有警告，因为该变量没有被使用
let a = 456;

// 但是如果 a 是常量就不合法：
const a: i32 = 123;
let a = 456;

```

### 基本类型

- i32 (32 位有符号整数)
- u32 (32 位无符号整数)
- f64 (64 位浮点数)
- bool (布尔类型)
- char (字符)

```rust
let x: i32 = 42
let y: f64 = 3.14
let is_true: bool = true
let letter: char = "A"
```

### 函数

Rust 函数通过 `fn` 关键字定义，函数的返回类型通过箭头符号 `->` 指定。

如果函数没有返回值，类型默认为 ()（即空元组）。

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### 控制流

#### if 表达式

```rust
let number = 7;
if number < 5 {
    println!("小于 5")
} else {
    println!("大于 5")
}
```

#### loop 循环

loop 是 Rust 中的无限循环，可以使用 break 退出循环

```rust
let mut counter = 0;

loop {
    counter += 1;
    if counter > 10 {
        break
    }
}
```

#### while 循环

```rust
let mut counter = 3;

while counter > 0 {
    println!("{}", counter);
    counter -= 1;
}
```

#### for 循环

```rust
for number in 1..4 {
    println!("{}", number);
}
```

### 所有权 (Ownership)

Rust 中的所有权是独特的内存管理机制，核心概念包括`所有权` (ownership)、`借用` (borrowing) 和`引用` (reference)。

**所有权规则:**

- Rust 中的每个值都有一个所有者。
- 每个值在任意时刻只能有一个所有者。
- 当所有者超出作用域时，值会被删除。

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 的所有权被转移给了 s2
// println!("{}", s1); // 此处编译会报错，因为 s1 已不再拥有该值
```

**借用和引用:**

借用允许引用数据而不获取所有权，通过 `&` 符号实现。

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);  // 借用
    println!("The length of '{}' is {}.", s, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

### 结构体 (Structs)

结构体用于创建自定义类型，字段可以包含多种数据类型。

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let user1 = User {
    username: String::from("tom"),
    email: String::from("tom@example.com"),
    sign_in_count: 1,
    active: true,
};
```

### 枚举 (Enums)

枚举允许定义可能的几种数据类型中的一种。

```rust
enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

### 模式匹配 (match)

match 是 Rust 中强大的控制流工具，类似于 switch 语句。

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
let result = value_in_cents(Coin::Dime);
println!("{}", result)
```

### 错误处理

Rust 有两种主要的错误处理方式：`Result<T, E>` 和 `Option<T>`。

**Result:**

```rust
#[derive(Debug)] // 为枚举派生 Debug trait，就可以用 {:?} 输出
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        return Result::Err(String::from("Division by zero"));
    } else {
        return Result::Ok(a / b);
    }
}
let res = divide(10, 0);
print!("{:?}", res);
```

**Option:**

```rust
// Option<T> 用于表示“可能有值，也可能没有值”的情况。
// Some(val) 表示有一个值，val 是具体的数据（比如 Some(10)）。
// None 表示没有值，相当于“空”或“缺失”。
fn get_element(index: usize, vec: &Vec<i32>) -> Option<i32> {
    if index < vec.len() {
        Some(vec[index])
    } else {
        None
    }
}

let v = vec![10, 20, 30];
// 感叹号 ! 表示这是一个“宏调用”，而不是普通的函数调用
// 1. vec! 是 Rust 标准库提供的宏，用于快速创建一个 Vec（动态数组）
// 2. 宏可以根据传入的参数生成代码，vec![10, 20, 30] 会自动生成一个包含 10、20、30 的 Vec<i32>
// 3. 感叹号 ! 是宏调用的标志，Rust 语法规定所有宏都要加 !
let res = get_element(1, &v);

match res {
    Some(val) => println!("元素值: {}", val),
    None => println!("索引越界"),
}
// 这段代码是对 get_element 函数的返回值进行模式匹配处理
// res 的类型是 Option<i32>，可能是 Some(val) 或 None
// Some(val)：如果 get_element 返回的是 Some，说明索引有效，取出元素值 val 并打印出来。
// None：如果返回的是 None，说明索引越界，打印“索引越界”。
```

### 所有权与借用的生命周期

Rust 使用生命周期来确保引用的有效性。生命周期标注用 'a 等来表示，但常见的情况下，编译器会自动推导。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### 重影（Shadowing）

重影的概念与其他面向对象语言里的"重写"（Override）或"重载"（Overload）是不一样的。重影就是刚才讲述的所谓"重新绑定"，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念。

重影就是指变量的名称可以被重新使用的机制：

```rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
}
```

这段程序的运行结果：

```rust
The value of x is: 12
```

重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。

```rust
let mut s = "123";
s = s.len();
```

这段程序会出错：不能给字符串变量赋整型值。
