页面输入 url 后

1. dns 域名解析获取 ip 地址
    - dns 缓存，获取 ip 地址后会缓存到本地
    - dns 负载均衡 dns 服务器上为一个主机配置多个 ip 地址，在应答 dns 查询时，dns 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，将压力分摊到不同的机器上
2. 建立 tcp 连接，3 次握手
    - client 发送数据包(SYN=1 Seq=x)到服务器端口，server 接受后，返回响应包(SYN=1，ACK=1+x， seq=y)，client 发送数据包(Seq=z，ACK=1+y)
3. 客户端发送 http 请求
    - http 缓存
        - 强缓存，判断本地缓存未过期则直接读取缓存，不用再次请求，如(200 from memory/disk cache)
        - 协商缓存
            - http1.0 If-Modified-Since(请求头上)/Last-Modified(响应头)，如果 If-Modified-Since 和 Last-Modified 匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到 1s 以内。
            - http1.1 If-None-Match(请求头上)/E-tag(响应头)，如果 If-None-Match 和 E-tag 匹配，则代表内容未变，通知浏览器使用本地缓存，和 Last-Modified 不同，E-tag 更精确，只要文件变，指纹就会变，而且没有 1s 精确度的限制
4. ~~服务器发送响应数据~~服务器处理请求，并返回 http 报文
    - 服务器上一般都会安装处理请求的应用——web server，例如 nginx
    - 传统的 MVC 模型 ，chrome 用户输入 -> 控制器接收 -> 传递给模型(Modal) -> Modal 与数据库进行存取 -> 选择对应视图(View) -> 将 HTML 返回给浏览器(chrome)
5. 解析数据，页面渲染

    - 浏览器的构成：
        - user interface(用户界面)，包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分
        - browser engine(浏览器引擎)，用来查询及操作渲染引擎的接口
        - rendering engine(渲染引擎)，用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来
        - networking(网络)，用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作
        - js 解释器，用来解释执行 JS 代码
        - UI backend(UI 后台)，用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口
        - DB Persistence(数据存储)，属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 web database 技术，这是一种轻量级完整的客户端存储技术
    - 浏览器的多进程：
        - Browser 进程：~~唯一，调控，多个窗口也只有一个~~，浏览器的主进程（负责协调、主控），只有一个
        - GPU 进程：~~渲染 3D~~，最多一个，用于 3D 绘制
        - 第三方插件进程：使用时创建
        - 浏览器渲染进程(内核)：默认每个 Tab 页面一个进程，互不影响，~~实现浏览器的~~控制页面渲染、脚本执行、事件处理，（有时候会优化，如多个空白 tab 会合并成一个进程）
            - 浏览器渲染进程包含多个线程
            - GUI 线程，用户图像界面/用户图像接口
            - js 引擎线程，执行 js 脚本
            - 事件~~处理~~触发进程
            - 定时器线程
            - 网络请求线程
    - 页面渲染流程
        1. 解析 html，构建 dom 树
        2. 解析 css，构建 css 规则树
        3. ~~结合~~合并 dom 树和 css 规则树，生成 render 树
        4. ~~计算 render 树各元素的布局和大小(layout/reflow)~~，布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算
        5. paint 绘制 render 树，绘制页面像素信息
    - 解析 html 过程：bytes -> ~~charts~~characters -> token -> nodes -> dom
        1. 转换 将获取的数据根据编码规则转译成一个个字符
        2. 分词 将生成的字符按 HTML 规范标准，转换成一个个不同的标记 token，~~包含其含义与规则集~~每个 token 都有自己独特的含义以及规则集
        3. 词法分析 将生成的 token 转换成对象，~~包含其属性与规则~~这些对象分别定义他们的属性和规则
        4. 构建 dom 根据生成的对象，构建 dom 树，因为 HTML 标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
    - 解析 css 过程和 html 类似：bytes -> ~~charts~~characters -> token -> nodes -> cssom
        - 参考解析 html
    - ~~生成 render 树，不是 dom 树上所有节点都渲染的，<body>及其内部的元素，且 display 不为 none~~，一般来说，渲染树和 DOM 树相对应的，但不是严格意义上的一一对应,因为有一些不可见的 DOM 元素不会插入到渲染树中，如 head 这种不可见的标签或者 display: none 等
    - 布局 render 树（Layout/Reflow），负责各元素尺寸、位置的计算
        - 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸。
    - 绘制 render 树，绘制页面像素信息
        - 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。
        - Layout，也称为 Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
        - Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

6. 4 次挥手，结束 tcp 连接
    - 发起方向被动方发送报文，Fin、Ack=y+1、Seq=x+2，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。
      (第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
    - 被动方发送报文，Ack=x+3、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。
      (第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
    - 被动方向发起方发送报文段，Fin、Ack、Seq=y+1，请求关闭连接。并进入 LAST_ACK 状态。
      (第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
    - 发起方向被动方发送报文段，Ack=y+2、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。
      (第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)
