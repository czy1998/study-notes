# 问题记录

## 1.父组件直接将`this.setState`传递给子组件，子组件调用报错

**背景**

```js
import React, { Component } from "react";

class Child extends Component {
  constructor(props) {
    super(props);
  }
  onClick = () => {
    this.props.add({ num: 2 });
  };
  render() {
    return <div onClick={this.onClick}>131</div>;
  }
}

class App extends Component {
  constructor() {
    super();
    this.state = {
      num: 1,
    };
  }
  render() {
    return (
      <div className="App">
        <h1>{this.state.num}</h1>
        <Child add={this.setState} />
      </div>
    );
  }
}
export default App;
```

点击`Child`的 131，控制台就报错了

```js
    Uncaught TypeError: Cannot read properties of undefined (reading 'enqueueSetState')
```

**原因**

猜测是 `this` 指向问题，由于没有研究过源码，不太清楚其内部逻辑

**解决办法**

```jsx
// App
<Child add={this.setState.bind(this)} />;

// Child
this.props.add({ num: 2 });
```

## 2.页面 A 使用了 react-router-dom 的 <Prompt /> 锁，页面 B 通过 this.props.history.push 跳转到页面 A 就触发了锁，出现了 window.confirm 弹窗

**背景**

页面 A、B 大致如下

```js
const PageA = () => {
  return (
    <div>
      <Prompt
        when={this.state.showPrompt}
        message={(location) => "编辑内容尚未保存，确定取消吗？"}
      />
    </div>
  );
};

...

const PageB = (props) => {
  const goPageA = () => {
    props.history.push('/pageA?tip=你好世界')
  }
  return <div>
    <a onClick={goPageA}>前往</a>
  </div>
}
```

**原因**

经排查是页面 B 的 push 方法引起的， url 中 tip 的值是中文

**解决办法**

将 url 上的参数使用 npm 包 `qs` 进行转换，或者使用 `window.encodeURIComponent` 方法处理

```js
import qs from "qs";
const str = qs.stringify({ tip: "你好世界" });

...

const str = `tip=${window.encodeURIComponent('你好世界')}`
```

## Prompt 拦截弹窗点击取消，url 变为了上一页的 url

### 背景

项目依赖: `react@^16.10.2`，`react-route-dom@^4.3.1`
路由组件: `HashRouter`

下游商务合作-委托方管理tab-列表，点击【提交资质信息】进入报告编辑页面，点击返回上一页，触发 `Prompt` 拦截弹窗，此时 `url` 变为上一页的 `url`，点击弹窗取消，当前页面 `url` 没有恢复。

找了个同样适用了 `Prompt` 组件的页面-企业详情页，同样操作，`url` 没有变更。

### 经历

从 `github` 拉取项目版本的 `react-route-dom` 与其的依赖项 `history`。

调试代码后得出:

- 资质列表使用的是 `history.back` 方法实现返回
- 企业详情使用的是 `history.replace` 方法返回

于是也想使用 `history.replace` 方法，遇到一个问题，需要知道上一页的 `url`，已知 `history api` 是无法获取历史 `url` 的，故此暂歇

尝试继续使用 `history.back`，其执行触发的监听方法 `fn1` 会先将 `url` 变更为上一页的 `preUrl`，弹窗点击取消时，会用 `preUrl` 在存放历史路径的数组 `allPaths` 中遍历，找到索引 `preIndex`，和当前页面 `url` 的索引 `index`，利用差值调用 `go` 方法切换路径（`go(index - preIndex)`）

调试代码发现，列表页我使用了 `hera-ui` 下 `Table` 的 `saveId`，其会让表格读取筛选项初始配置，加密后添加在 `url` 的 ? 后面，这就引发了一个问题。

首次进入列表页时，`url` 为 `/Business/SigningInfo1` 将其命名为 `urlA` ，表格加载之后 `url` 为 `/Business/SigningInfo1?TableA=W29iamVjdCBPYmplY3Rd` 将其命名为 `urlB`。

在进入列表页时，存放历史路径的数组 `allPaths` 会把 `urlA` 推入，然后进入报告编辑页时，会用 `urlB` 寻找索引，此时就寻找不到，导致 `go` 方法执行错误，无法正常恢复 `url`

### 解决办法

1. 给前往表单页的页面 `prePage`，在其调用 `history.push` 方法前，使用 `history.replace(location.hash.slice(1))` 更新 `allPaths` 中 `prePage` 的 `url`，这样能解决标题问题，但又会引发新的问题:
   - 点击取消后，`url` 是恢复了，使用 `setBreadcrumb` 手动设置的面包屑丢失了，需要重新设置。
   - 在表单页刷新页面后，点击返回，`url` 没有恢复，这是因为刷新后，`allPaths` 被重置了，其中只含有当前页面一个 `url`，`go` 方法就执行错误了

2. 给前往表单页的页面 `prePage`，在其调用 `history.push` 方法前，将当前页面 `url` 存入 `storage` 做为表单页 `replace` 方法执行的参数，需要注意的有:
   - 离开表单页后需要清除设置的 `storage`
   - 点击取消后，`url` 是恢复了，使用 `setBreadcrumb` 手动设置的面包屑丢失了，需要重新设置。
