# 问题记录

### 1.父组件直接将`this.setState`传递给子组件，子组件调用报错

**背景**

```js
import React, { Component } from "react";

class Child extends Component {
  constructor(props) {
    super(props);
  }
  onClick = () => {
    this.props.add({ num: 2 });
  };
  render() {
    return <div onClick={this.onClick}>131</div>;
  }
}

class App extends Component {
  constructor() {
    super();
    this.state = {
      num: 1,
    };
  }
  render() {
    return (
      <div className="App">
        <h1>{this.state.num}</h1>
        <Child add={this.setState} />
      </div>
    );
  }
}
export default App;
```

点击`Child`的 131，控制台就报错了

```js
    Uncaught TypeError: Cannot read properties of undefined (reading 'enqueueSetState')
```

**原因**

猜测是 `this` 指向问题，由于没有研究过源码，不太清楚其内部逻辑

**解决办法**

```jsx
// App
<Child add={this.setState.bind(this)} />;

// Child
this.props.add({ num: 2 });
```

### 2.页面 A 使用了 react-router-dom 的 <Prompt /> 锁，页面 B 通过 this.props.history.push 跳转到页面 A 就触发了锁，出现了 window.confirm 弹窗

**背景**

页面 A、B 大致如下

```js
const PageA = () => {
  return (
    <div>
      <Prompt
        when={this.state.showPrompt}
        message={(location) => "编辑内容尚未保存，确定取消吗？"}
      />
    </div>
  );
};

...

const PageB = (props) => {
  const goPageA = () => {
    props.history.push('/pageA?tip=你好世界')
  }
  return <div>
    <a onClick={goPageA}>前往</a>
  </div>
}
```

**原因**

经排查是页面 B 的 push 方法引起的， url 中 tip 的值是中文

**解决办法**

将 url 上的参数使用 npm 包 `qs` 进行转换，或者使用 `window.encodeURIComponent` 方法处理

```js
import qs from "qs";
const str = qs.stringify({ tip: "你好世界" });

...

const str = `tip=${window.encodeURIComponent('你好世界')}`
```
