# shell

### 概念

Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言

Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务

### 使用

一些指令用法可前往 [linux 常用指令](../linux/常用指令)

#### 语法

[部分语法应用在了 git hook 中](../git/husky.md)

1.  `$( )` 与 ` ` 命令的替换

    - 含义：`$( )`和 ` ` 表示 "命令的替换"
    - 原理：将对反引号或`$( )`里的内容先进行执行，然后将执行的结果代换到当前命令中
      在 shell 中 fork 一个子进程区做他们括起来的命令,然后在返回父进程

    - 在编写脚本过程中尽量使用`$( )`来进行命令替换，理由如下：
      - 🎈 ` ` 很容易与 '' 搞混乱，尤其对初学者来说
      - 🎈 在多层次的复合替换中，` `必须要额外的转义字符处理（反斜线），而`$( )`比较直观
      - 🎈 `$( )`的弊端是，并不是所有的类 unix 系统都支持这种方式，但反引号是肯定支持的
    - 例如：

      ```sh
      [root@C ~]# echo date # 输出字符串 date
      date

      [root@C ~]# echo `date`
      2024年 5月17日 星期五 14时33分49秒 CST # 输出时间字符串


      [root@C ~]# echo $(date)
      2024年 5月17日 星期五 14时33分57秒 CST # 输出时间字符串
      ```

2.  `#{ }` 变量替换

    - 一般情况下，`$var` 与 `${var}` 是没有区别的，但是用 `${ }` 会比较精确的界定变量名称的范围
    - 例如：

      ```sh
      [root@C ~]# A=Linux
      [root@C ~]# echo $AB #表示变量 AB

      [root@C ~]# echo ${A}B #表示变量A后连接着B
      LinuxB
      ```

    - 🎈 `${ }` 内部还支持"变量替换"、"变量截取"、"变量删除"

3.  `$[]` 与 `$(())` 整数运算
    它们是一样的，都是进行数学运算的。支持+ - \* / %：分别为 “加、减、乘、除、取模”

    - 例如：

      ```sh
      [root@C ~]# echo $[1+1+1]
      3

      [root@C ~]# echo $([(1+1+1))
      3
      ```

4.  `[ ]` 判断符号
    即为 test 命令的另一种形式

    - 左中括号是调用 test 的命令标识，右中括号是关闭条件判断的
    - 注意：表达式与中括号左右要空出空格
    - 例如：
      ```sh
      [root@C ~]# A=123
      [root@C ~]# B=123
      [root@C ~]# [ $A=$B ] && echo 123
      123
      [root@C ~]# [ $A==$B ] && echo 123
      123
      ```

5.  `(( ))` 与 `[[ ]]`
    它们分别是`[ ]`的针对`数学比较表达式`和`字符串表达式`的加强版

    1. 双小括号 `(( ))`
       - 语法：`((exp))`
       - exp 为`算数表达式`，表达式结果为 0，则返回退出的状态码为 1，后续的命令不会执行；表达式结果为 0，则返回退出的状态码为 0，后续的命令会执行
       - exp 为`逻辑判断`，表达式结果为 false，则状态码为 1；表达式结果为 true，则状态码为 0
       - 双括号中的变量可以不使用 $ 符号前缀。括号内支持多个表达式用逗号分开
    2. 双中括号 `[[ ]]`

6.  `( )` 与 `{ }`的区别

    - 相同点：
      - `( )` 和 `{ }` 都是把一串的命令放在括号里面，如果命令在一行，则命令之间用 `;` 隔开
    - 不同点：
      - `( )` 只是把一串命令重新开一个子 shell 进行执行，不影响当前 shell 环境；`{ }` 对一串命令在当前 shell 执行,影响当前 shell 环境
    - 例如：

      ```sh
      [root@C ~]# A=123
      [root@C ~]# echo $A
      123
      [root@C ~]# ($A==123;echo 666)
      666
      [root@C ~]# (A=222;echo $A)
      222
      [root@C ~]# echo $A
      123
      [root@C ~]# {$A==123;echo 666}
      666
      [root@C ~]# {A=222;echo $A}
      222
      [root@C ~]# echo $A
      222
      ```

7.  `==` 与 `=` 的区别
    == 可用于判断变量是否相等，= 除了可用于判断变量是否相等外，还可以表示赋值

    - = 与 == 在 [ ] 中表示判断(字符串比较)时是等价的
      - 例如：
        ```sh
        [root@C ~]# [ 1=1 ] && echo 123
        123
        [root@C ~]# [ 1==1 ] && echo 123
        123
        ```
    - 在 (( )) 中 = 表示赋值， == 表示判断(整数比较)，它们不等价
      - 例如：
        ```sh
        [root@C ~]# ((1=1)) && echo 123
        zsh: bad math expression: lvalue required # 错误的数学表达式，需要左值
        [root@C ~]# ((1==1)) && echo 123
        123
        ```

8.  $0、$1-9、$#、$?、$\*、$@、$!、$、$-、$IFS 含义及举例

    - $0：当前执行的 Shell 脚本的文件名
    - $1-$9：当前 Shell 脚本的参数 1-9
    - $#：当前 Shell 脚本的参数数量
    - $?：上一次执行的命令的退出状态
    - $\*：所有当前 Shell 脚本的参数，作为一个单独的字符串
    - $@：所有当前 Shell 脚本的参数，作为多个独立的字符串
    - $!：上一次在后台运行的任务的进程 ID
    - $$：当前 Shell 脚本的进程 ID
    - $-：获取当前 Shell 的选项标志
    - $IFS：指定 Shell 脚本中的字段分隔符

9.  单引号 与 双引号
    - `单引号`包裹后，所有内容都是原样输出，不进行变量或命令替换
    - `双引号`包裹后，允许变量替换和命令执行，但仍然可以使用反斜杠来转义需要的字符
    - 例如
      ```sh
      echo '$USER' # 输出 $USER
      echo "$USER" # 输出 admin
      ```

#### 案例

1. Demo1

   ```sh
   [root@C ~]# env
   ```

   - 直接在 shell 中输入 env + 回车，可以输出系统所有的环境变量与其值

2. Demo2

   ```sh
   #!/usr/bin/env sh
   echo hello world
   ```

   - 代码第一行 是一种特殊的注释，称为 Shebang 或 Sha-bang、hashbang 注释
   - 该注释由一下几个部分组成：
   - `#!`: 是一个约定的标记，它告诉系统该文件应该被当作一个脚本文件来执行，并且后面的路径是解释这个脚本的程序的路径，上述代码含义即：使用哪一种 Shell
   - `/usr/bin/env`: 这是一个常见的 Unix 命令，用于在系统的 PATH 环境变量中查找并运行指定的程序。
     使用 env 可以确保脚本在任何用户的 PATH 环境中都能找到并运行指定的解释器，而不仅仅是默认的或硬编码的路径
   - `sh`: 告诉操作系统这个脚本应该用 sh 解释器来执行
   - 整体的效果为: 告诉系统使用通过 `/usr/bin/env` 来查找 sh 解释器，`env` 命令会在环境变量 PATH 中搜索 sh 解释器，并使用找到的第一个

3. Demo3

   ```sh
   # .zshrc
   export NVM_DIR="$HOME/.nvm"
   [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
   ```

   - 上面是 zsh 配置文件里的一段代码
   - 第一行：设置 NVM_DIR 环境变量为当前用户主目录下的 .nvm 目录，使得所有 NVM 命令和操作都能找到这个目录
   - `export` 命令用于设置一个环境变量，使其在所有子进程中可用
   - `NVM_DIR` 是一个环境变量，指定 NVM 安装的位置
   - `$HOME/.nvm` 是 NVM 默认的安装目录，`$HOME` 代表当前用户的主目录
   - 第二行：检查 nvm.sh 脚本是否存在且非空，如果存在且非空，则加载 nvm.sh 脚本，从而使得 NVM 功能在当前 Zsh 会话中可用
   - `[ -s "$NVM_DIR/nvm.sh" ]` 是一个条件测试，检查 $NVM_DIR/nvm.sh 文件是否存在且大小是否大于零
     - `-s` 选项检查文件是否存在且非空
   - `&&` 是逻辑 AND 运算符，只有在前一个命令成功（返回状态码为 0）时才执行后面的命令
   - `\. "$NVM_DIR/nvm.sh"` 使用 .（也称为 source）命令在当前 shell 环境中执行 nvm.sh 脚本

### 问题解答

1. `. demo/a.sh`与`demo/a.sh`的区别

   在 Unix/Linux shell 环境中，上述两条指令实际上代表了不同的路径解析方式，但最终都可能用于运行 a.sh 脚本，具体差异如下：

   - `. demo/a.sh`

   - 这条指令使用点命令`.`（也可以写作 source）来执行 demo/a.sh 脚本
   - `.`命令会**读取并执行**指定 shell 脚本文件中的命令，而**不是启动一个新的**子 shell 进程
   - 这意味着脚本中定义的变量、函数或改变的**环境设置会影响**到当前 shell 环境。这对于需要修改当前 shell 环境（如设置环境变量）的脚本特别有用
   - 因为该指令是**读取**指定文件的命令，在当前有执行权限的 shell 里执行，所以不会有权限错误

   - `demo/a.sh`

   - 这条指令是直接调用或执行 demo/a.sh 脚本的标准方式
   - 在这种情况下，脚本会在一个**子 shell 环境中运行**
   - 这意味着脚本内部的变量定义、函数以及环境变量的修改**不会影响**到调用它的父 shell。一旦脚本执行完毕，子 shell 关闭，所有在子 shell 中所做的环境更改都会丢失
   - 单独运行时可能会出现 `permission denied` 错误

   - Linux/Unix 系统有严格的文件权限机制
   - 默认情况下，新创建的文件没有可执行权限，文件所有者（owner）、特定用户组（group）读取（read）、写入（write）、执行（execute）
   - 通过 `ls -l` 命令即可知该文件没有执行权限

   ```sh
       ls -l demo/a.sh
       # -rw-r--r--
   ```

   - 可以通过 chmod 命令给 a.sh 文件添加执行权限
